from venv import logger
import json
import re
from datetime import datetime
import pytz
import hashlib
import traceback
from selenium import webdriver
from selenium.common.exceptions import WebDriverException
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import NoSuchElementException
from selenium.common.exceptions import TimeoutException
from selenium.webdriver.common.action_chains import ActionChains
from pymongo import MongoClient
from bson import ObjectId
import logging
from argostranslate import package, translate
import argostranslate.package, argostranslate.translate
from langdetect import detect


logger = logging.getLogger(__name__)

def read_config(filename):
    try:
        with open(filename, 'r') as config_file:
            config = json.load(config_file)
        return config
    except FileNotFoundError:
        logging.error(f"Config file '{filename}' not found.")
        return None
    except json.JSONDecodeError:
        logging.error(f"Error decoding JSON file: {filename}")
        return None

def hash_sha256(content):
    # Serialize the dictionary in a consistent manner using JSON
    serialized_content = json.dumps(content, sort_keys=True)
    # Hash the serialized content using SHA-256
    return hashlib.sha256(serialized_content.encode('utf-8')).hexdigest()

def translate_to_english(text, language=None):
    try:
        if not text:
            return text
        if language == None:
            detected_language = detect(text)
            if detected_language == "zh-cn":
                detected_language = "zh"
            
            if detected_language == 'en':
                return text
        else:
            detected_language = language

        installed_languages = translate.get_installed_languages()
        source_lang_code = next((lang.code for lang in installed_languages if lang.code == detected_language), None)
        
        if source_lang_code is None:
            raise ValueError(f"Language '{detected_language}' is not supported.")
        
        translation = translate.translate(text, source_lang_code, 'en')
        return translation
    except:
        return text

def find_one_document(key, value, collection_name, database):
    config = read_config("config.json")
    mongo_uri = config.get("mongo_uri")
    client = MongoClient(mongo_uri)  # Connect to MongoDB
    db = client[database]  # Connect to the database
    collection = db[collection_name]  # Connect to the collection
    query = {key: value}
    # If the query is based on '_id' and is a string, convert it to ObjectId
    if '_id' in query and isinstance(query['_id'], str):
        query['_id'] = ObjectId(query['_id'])

    return collection.find_one(query)

def datetime_to_string(dt):
    """ Convert datetime object to string. """
    return dt.isoformat()

def insert_into_mongo(database, collection_db, data_list, unique_identifier, second_unique_identifier=None):
    config = read_config("config.json")
    mongo_uri = config.get("mongo_uri")
    try:
        if isinstance(data_list, str):
            # If data_list is a string, parse it as JSON
            data_list = json.loads(data_list)

        if isinstance(data_list, dict):
            data_list = [data_list]  # Wrap the dictionary in a list

        client = MongoClient(mongo_uri)
        db = client[database]
        collection = db[f"{collection_db}"]

        # Create index based on the presence of a second unique identifier
        if second_unique_identifier:
            collection.create_index([(f"{unique_identifier}", 1), (f"{second_unique_identifier}", 1)], unique=True)
        else:
            collection.create_index([(f"{unique_identifier}", 1)], unique=True)

        for data in data_list:
            # Construct query based on the provided unique identifiers
            if second_unique_identifier:
                query = {f"{unique_identifier}": data[f"{unique_identifier}"],
                         f"{second_unique_identifier}": data[f"{second_unique_identifier}"]}
            else:
                query = {f"{unique_identifier}": data[f"{unique_identifier}"]}

            update = {"$set": data}
            collection.update_one(query, update, upsert=True)

        logger.info("Data updated/inserted successfully into MongoDB.")
        return True
    except Exception as e:
        logger.error(f"Failed to update/insert data into MongoDB. Error: {e}")
        return False

def retrieve_key_list(collection_name, unique_key, database):
    config = read_config("config.json")
    mongo_uri = config.get("mongo_uri")
    client = MongoClient(mongo_uri)  # Connect to MongoDB
    db = client[database]  # Connect to the database
    collection = db[collection_name]  # Connect to the collection

    list = []
    for document in collection.find():  # Iterate over all documents
        if unique_key in document:  # Check if 'subforum_link' key exists
            list.append(document[unique_key])  # Add the value to the list

    return list

def contains_any_word(text, words):
    """
    Check if any of the words in the list 'words' is present in 'text'.
    The search is case-insensitive and will match words irrespective of their position.

    :param text: str - The text to search in.
    :param words: list - The list of words to search for.
    :return: bool - True if any word is found, False otherwise.
    """
    for word in words:
        # Create a regular expression pattern for the word
        # \b represents a word boundary, so that partial matches are avoided
        # re.IGNORECASE makes the search case-insensitive
        pattern = r'\b' + re.escape(word) + r'\b'
        if re.search(pattern, text, re.IGNORECASE):
            return True
    return False

def initialize_driver():
    try:
        config = read_config("config.json")
        gecko_driver_path = config.get("gecko_driver_path")
        firefox_path = config.get("firefox_path")
        service = Service(f"{gecko_driver_path}")  # Path to geckodriver
        service.start()
        firefox_options = webdriver.FirefoxOptions()
        firefox_options.binary_location = f"{firefox_path}"
        driver = webdriver.Firefox(service=service, options=firefox_options)
    except WebDriverException as e:
        print("Error occurred while starting the GeckoDriver Service.")
        print(traceback.format_exc())   
    return driver, service, firefox_options

def update_post_counts_new(num_new_posts, key, value, collection, database):
    # Retrieve the tracking document
    query = {key: value}
    key_name = list(query.keys())[0]
    tracking_data = find_one_document(key, value, collection, database)
    tracking_data['daily'] += num_new_posts
    tracking_data['weekly'] += num_new_posts
    tracking_data['monthly'] += num_new_posts
    tracking_data['total'] += num_new_posts
    tracking_data['last_updated'] = datetime_to_string(datetime.now(pytz.utc))
    tracking_data.pop('_id', None)

    insert_into_mongo(database, collection, tracking_data, key_name)